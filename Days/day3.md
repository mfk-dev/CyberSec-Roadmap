# Day 3

- Realized that i was going in the wrong path.
- I was trying to get in directly bug bounty instead of learning cyber security even though this repository is named cyber security.
- So, i decided to try more "Cyber Security" kinda things instead of "Bug Bounty" kinda things.
- My progress of today:

## Report of the day:

## ---

- Date: January 31, 2026
- Status: Basic Concepts Completed (First Stage)

## ---

### 1. The Ontological Nature of Software (Rules and Assumptions)
- What I Learned: I learned that software is actually an artificial world made up of our assumptions and dreams.
- Software systems are essentially dependent on our design; if there is an error in our design, it creates a “vulnerability.” If a system rule can be bent, there is a potential weakness there.

### 2. The Necessity of Mathematical Expression
- What I Learned: I learned that for a concept to be translated into software, it must first be expressed mathematically.
- Mathematics: Software is based on mathematics, algebra (a subfield of mathematics), and, at its core, algorithms. Something that cannot be proven mathematically cannot be proven in software either. Algoritm was first introduced by “Harezmi”.

### 3. Technology and Information Economy Concepts
- What I Learned: I learned that technology is a combination of “Tool + Word” (Tekhne + Logos).
- I understood the critical level of cybersecurity.

### 4. Software Domination and Critical Sectors
- What I learned: I learned that software permeates every aspect of our lives; in particular, banking, the judiciary (UYAP), police, and military systems are entirely software-based.

### 5. Remote Work and Degrees
- What I Learned: I learned that even without a degree in the software world, you can work remotely from home and do work on a global scale.
- Bug bounty, digital nomadism, and freelancing are some of the best examples of remote work.

### 6. Language Barrier
- What I Learned: I learned that a foreign language (English) is an essential requirement in this industry.

### 7. Software as a Profession
- What I Learned: I learned that software is a profession where we tell the computer what tasks to perform and how to perform them, and then we code it.
- Cybersecurity: The computer only does what it is told to do. If we tell the computer (through code) to do something wrong or manipulate what it is told to do, we can take control of the system.

### 8. Analytical Thinking and Numerical Requirements
- What I Learned: I learned that analytical thinking is fundamental to software and that every software developer must be able to create numerical modules and apply methods to them.
- Example: When analyzing a complex attack, a cybersecurity expert breaks it down into small numerical pieces. They observe a website not as an “image” but as “modules and data flows.”

### 9. The 4 Fundamental Thought Structures of a Software Developer
- What I Learned: I learned that a software developer must think virtually, analytically, results-oriented, and algorithmically.

### 10. The 3 Elements of Transitioning to the Virtual World
- What I Learned: To be successful in the virtual world, knowing how to code is not enough; analytical thinking, interpersonal skills, and the ability to access new information (continuous learning) are essential.

### 11. Programming Language and Compilation Logic
- What I Learned: I learned that programming languages are tools for giving commands to computers and that the code we write is converted into the machine's only understandable language, 0s and 1s, via a “compiler.”
- Example: Hackers sometimes interfere directly with the compiled code rather than the source code; this is called reverse engineering.

### 12. Language Hierarchy
- What I Learned: I learned that languages have a hierarchy; at the top are languages close to human language (High-Level), and at the bottom are languages close to the machine (Low-Level).

### 13. Language Selection
- What I Learned: I learned that languages like Python, Go, and Rust will be popular by 2026, but what really matters is “learning one language very well” and transferring that logic to others. 
- I understood that practice (application) is superior to everything else.



## Summary of Steps 1-3:
- Software is a mathematical and fictional cyber world based on algorithms that can run on hardware. 
- If you make a mistake in fiction, an error occurs in your cyber world, and you fall into the hands of hackers.
- If you cannot do something with mathematics, you cannot do it with software, but you cannot do everything you can do with mathematics with software either. 
- Software is a technology, and the word technology comes from the combination of the Latin words Tekhno (Tool) and Logos (Word). 

## Summary of Steps 4-6:
-Software is the world's greatest power today and in the future. It is directly linked to the economy, education, and politics.
--Even though it covers almost everything right now, it is still a wide-open sector with new products coming out and being updated every day.
-Foreign languages are indispensable for software, but things like diplomas are dispensable, because there are also many opportunities for remote work in software.
-But of course, because it is such a broad sector, there is also a great need for security, which is where cybersecurity comes in.

## Summary of Steps 7-10:
-Software is the art of “giving commands” to a computer. When giving these commands, we translate life into numbers and methods.
-To exist in the virtual world, we must make our brains work like algorithmic machines, but we must not neglect human relationships and continuous learning.

## Summary of Steps 11-13:
-Programming languages are the translators between us and the machine. Learning a single language like a native language will be beneficial.
-Because at the heart of all languages lies the same thing: Algorithms and Analytical Thinking. 
-To ensure that languages stick in your mind and are fully learned, practice and application are ESSENTIAL.

## See you at day 4.
# - MFKDev
